

# 1. 정적/동적 웹 사이트

---

# 2. AJAX

: Asynchronous JS and XML

- 웹페이지 전체를 새로고침하지 않고, 필요한 데이터만 요청 후 일부만 업데이트(새로고침)
- Asynchronous 통신 방식: 사용자는 응답을 기다리지 않고(백그라운드에서 데이터를 찾아서 줌) 웹 페이지 사용 가능
- 데이터 전송 방식(XML): But, Json으로 전송해도 AJAX라고 함!

---

# 3. JSON(JS Object Notaion)

: JS 객체 문법으로 나타낸 문자열 형태의 포맷이다. 서버와 클라이언트의 데이터 통신 시 자주 사용하는 포맷.

- Parsing: JSON → JS 객체
- Stringification(문자열화): JS객체 → JSON

Q. 강의자료 12페이지에 `response.json()`가 응답 데이터를 JSON 객체로 파싱한다고 적혀있었다.
JSON의 parsing, stringification의 정의에 따르면 JS객체와 JSON문자열의 관계인데, 왜 'JSON객체'라는 워딩이 나온 걸까?

<img width="1417" height="945" alt="image" src="https://github.com/user-attachments/assets/1fd68d20-0365-4e15-a404-d6ff3934ea44" />

-> GPT
정확히는
JSON은 객체(Object)가 아니라 문자열 데이터 포맷
자바스크립트 객체(Object)와 문자열로 표현된 JSON을 왔다갔다 할 수 있음

교수님 주석은 학생 이해를 쉽게 하려고 편의상 ‘JSON 객체’라고 쓴 것일 가능성이 큼.
하지만 정확하게 말하면 response.json()은 JSON → JS 객체 변환 과정

“JSON 객체” = ❌ (틀린 표현, 실제론 없음)
“JSON 문자열” ✅
“JavaScript 객체” ✅

---

# 4. Json-Server

- 백엔드 서버를 구축하지 않고 JSON 파일만 있으면 RESTful API 생성 가능 → 테스트, 프로토타입 작업 용이
- 실행 코드
    
    ```bash
    json-server --port 9999 todos.json
    ```
    
    → http://localhost:9999/todos/2 → id가 2인 객체를 get 요청하는 url
    

---

# 5. Fetch API

### fetch에 보내는 url 인자

```jsx
fetch(url)

```

- `url`을 인자로 주면 **기본값으로 GET 요청**을 보냅니다.
- `fetch("http://localhost:9999/todos/2")`나
    
    `fetch("http://localhost:9999/todos?id=2")` 둘 다 똑같이 **GET 요청**을 날려요.
    

즉, 별도 설정 안 하면 `fetch`는 무조건 GET입니다.

---

### 두 URL의 차이

- `http://localhost:9999/todos/2`
    
    → **RESTful 방식**: 특정 리소스(`id=2`인 todo)를 의미
    
    → 보통 서버 라우터에서 `/todos/:id` 형태로 처리
    
- `http://localhost:9999/todos?id=2`
    
    → **쿼리스트링 방식**: todos를 조회하는데, 조건으로 `id=2`를 줌
    
    → 서버 라우터에서 `/todos` 요청을 받되, query parameter `id`를 읽어서 처리
    

---

```jsx
const url = new URL('http://localhost:9999/todos');
const params = new URLSearchParams({ id : 2 });
url.search = params;

fetch(url)
	.then ~ 뒤는 생략 ~
```

위 코드에서 `fetch(url)`에 전달되는 **최종 URL은 `"http://localhost:9999/todos?id=2"`** 

### `URL` 객체

- `new URL('http://example.com/path?x=1')` 처럼 브라우저(또는 Node의 WHATWG URL)에 내장된 객체예요.
- URL을 구성 요소(프로토콜, 호스트, pathname, search, hash 등)로 쉽게 다룰 수 있게 해줍니다.
- 주요 프로퍼티:
    - `url.href` or `url.toString()` : 전체 문자열 URL
    - `url.protocol`, `url.hostname`, `url.port`, `url.pathname` 등
    - `url.search` : 쿼리 문자열(앞에 `?` 포함된 문자열)
    - `url.searchParams` : `URLSearchParams` 객체

### `URLSearchParams`

- 쿼리 문자열을 만들고 다루기 위한 편리한 인터페이스입니다.
- 생성 가능:
    - `new URLSearchParams('a=1&b=2')`
    - `new URLSearchParams({ a: 1, b: 2 })` (값들은 문자열로 변환됨)
- 유용한 메서드: `append`, `set`, `get`, `getAll`, `has`, `delete`, `toString`, `sort` 등.
    - `params.toString()` → `'a=1&b=2'` (자동으로 URL-인코딩 처리)

### `url.search` vs `url.searchParams`

- `url.search`는 **문자열**(예: `'?id=2&x=3'`)입니다.
- `url.searchParams`는 **`URLSearchParams` 객체**로 쿼리 파라미터를 조작할 수 있게 해줍니다.
- 둘은 연결되어 있어 `url.searchParams.set('id','2')`를 하면 `url.search`도 자동으로 바뀝니다.

### 코드 한 줄씩 동작 설명

```jsx
const url = new URL('http://localhost:9999/todos');
const params = new URLSearchParams({ id : 2 });
url.search = params;

fetch(url)
  .then( /* ... */ )

```

1. `new URL('http://localhost:9999/todos')`
    - `url`은 pathname `/todos`를 가진 URL 객체가 됩니다.
2. `new URLSearchParams({ id: 2 })`
    - `params`는 쿼리 파라미터 객체이고, `params.toString()`은 `'id=2'` 입니다.
3. `url.search = params;`
    - 여기서 `params`(객체)는 내부적으로 문자열로 변환되어 (`params.toString()`) `url.search`에 들어갑니다.
    - 결과적으로 `url.search === '?id=2'` 이 됩니다. (브라우저가 `?`를 붙여줍니다.)
    - **주의**: 보통은 `url.search = params.toString()` 또는 `url.searchParams = params` 혹은 `url.searchParams.set('id','2')`처럼 명시적으로 쓰기도 합니다. 하지만 `url.search = params`처럼 `URLSearchParams` 객체를 할당해도 문자열로 변환되어 동작합니다.
4. `fetch(url)`
    - `fetch`에 `URL` 객체를 넘기면 내부적으로 `url.toString()` (또는 `String(url)`)이 호출되어 **문자열 형태의 전체 URL**로 요청을 보냅니다.
    - 따라서 보내는 요청은 `GET http://localhost:9999/todos?id=2` 입니다.

---

## 1. GET 요청

```html
<script>
		// 1. promise then/catch 사용
    fetch('http://localhost:9999/todos')
        .then((response)=>{ // "서버가 클라이언트에게 보내준" HTTP "응답 전체"를 나타내는 Response 객체
            if(!response.ok){
                throw new Error('Network response was not ok');
            }
            return response.json()
        })
        .then((data)=>{
            console.log(data);
        })
        .catch((error)=>{
            console.error('Fetch error:', error);
        });
				
				// 2. async/await 사용
        const getTodos = async ()=>{
            try{
                const response = await fetch('http://localhost:9999/todos'); // 서버로 GET 요청 보냄
                if(!response.ok){
                    throw new Error('Network response was not ok');
                }

                const data = await response.json(); // response.json()은 비동기 메서드
                console.log(data);
            } catch(error){
                console.error('Fetch error:',error);
            }
        };
        getTodos();
</script>

```

<img width="1501" height="931" alt="image" src="https://github.com/user-attachments/assets/d9278cf0-66d9-4326-bc76-1f91a8fb5419" />


---

### id가 1인 경우만 GET

```html
<script>
    fetch('http://localhost:9999/todos?id=1')
        .then((response)=>{
            if(!response.ok){
                throw new Error('Network response was not ok');
            }
            return response.json()
        })
        .then((data)=>{
            console.log(data);
        })
        .catch((error)=>{
            console.error('Fetch error:', error);
        });
</script>

```

## 2. POST 요청

- Promise 체인 방식

```html
<script>
    const postData = {
        title: 'Learn NodeJS',
        completed: false
    };

    fetch('http://localhost:9999/todos',{
        method: 'POST',
        headers:{
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(postData) // 문자열로 변환하여 전송
    })
        .then((response)=>{
            if(!response.ok){
                throw new Error('Network response was not ok');
            }
            return response.json()
        })
        .then((data)=>{
            console.log(data);
        })
        .catch((error)=>{
            console.error('Fetch error:', error);
        });
</script>

```

- async, await 방식

```html
<script>
        const postTodos = async ()=>{
            try{
                const response = await fetch('http://localhost:9999/todos',{
                    method : 'POST',
                    headers : {
                        'Content-Type':'application/json'
                   },
                    body : JSON.stringify({
                        title: 'Express 공부하기',
                        completed: false
                    })
                });
                if(!response.ok){
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                console.log(data);
            } catch(error){
                console.error('Fetch error:',error);
            }
        };
        postTodos();
</script>

```

---

## 3. PUT 요청

```html
<script>
    const putData = {
        title: 'Learn React',
        completed: false
    };

    fetch('http://localhost:9999/todos/1',{
        method: 'PUT',
        headers:{
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(putData)
    })
        .then((response)=>{
            if(!response.ok){
                throw new Error('Network response was not ok');
            }
            return response.json()
        })
        .then((data)=>{
            console.log(data);
        })
        .catch((error)=>{
            console.error('Fetch error:', error);
        });
</script>

```

```html
<script>
        const putTodos = async ()=>{
            try{
                const response = await fetch('http://localhost:9999/todos/1',{
                    method : 'PUT',
                    headers : {
                        'Content-Type':'application/json'
                    },
                    body : JSON.stringify({
                        title: 'Learn JS',
                        completed: true
                    })
                });
                if(!response.ok){
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                console.log(data);
            } catch(error){
                console.error('Fetch error:',error);
            }
        };
        putTodos();
</script>

```

## 4. DELETE 요청

```html
<script>
    fetch('http://localhost:9999/todos/1',{
        method: 'DELETE',
    })
        .then((response)=>{
            if(!response.ok){
                throw new Error('Network response was not ok');
            }
            return response.text().then(text=>text?JSON.parse(text):{});
        })
        .then((data)=>{
            console.log('Successfully deleted: ', data);
        })
        .catch((error)=>{
            console.error('Fetch error:', error);
        });
</script>

```

```html
<script>
        const deleteTodos = async ()=>{
            try{
                const response = await fetch('http://localhost:9999/todos/2',{
                    method : 'DELETE',
                });
                if(!response.ok){
                    throw new Error('Network response was not ok');
                }
                const data = await response.text().then(text=>text?JSON.parse(text):{});
                console.log('Successfully deleted: ', data);
            } catch(error){
                console.error('Fetch error:',error);
            }
        };
        deleteTodos();
</script>

```

```jsx
return response.text()
    .then(text => text ? JSON.parse(text) : {});

```

---

### 1. `response.text()`

- 서버의 응답(body)을 **문자열(String)** 로 꺼내옵니다.
- `response.json()`과 달리, 자동으로 파싱하지 않고 그냥 텍스트 그대로 줍니다.

예를 들어 서버가 빈 응답을 주면 `""` (빈 문자열)을 반환합니다.

---

### 2. `.then(text => text ? JSON.parse(text) : {})`

- `text`가 비어 있지 않으면(`truthy`) → `JSON.parse(text)` 실행해서 JS 객체로 변환
- `text`가 비어 있으면(`""` → falsy) → 그냥 빈 객체 `{}` 반환

즉,

- 응답 본문이 JSON 문자열일 경우에는 정상적으로 파싱
- 응답 본문이 **빈 문자열**일 경우에는 에러 나지 않도록 안전하게 `{}`를 대신 반환

---

### 3. 왜 이렇게 쓸까?

`DELETE` 요청의 응답은 보통 **본문이 없는 경우**가 많습니다.

(HTTP 204 No Content 같은 경우)

- 만약 그냥 `response.json()`을 쓰면:
    
    → 빈 문자열을 JSON으로 파싱하려다가 에러가 납니다.
    
- 그래서 `response.text()`로 문자열을 꺼내고,
    
    → 있으면 `JSON.parse` 하고,
    
    → 없으면 `{}` 반환해서 안전하게 처리하는 거예요.
    

---

✅ 정리하면:

```jsx
return response.text().then(text => text ? JSON.parse(text) : {});

```

👉 **“응답 본문이 있으면 JSON으로 파싱, 없으면 빈 객체로 반환”** 이라는 안전장치입니다.

---

# Axios API

## 1. GET 요청

### 모든 todos 보기

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    axios
    .get('http://localhost:9999/todos')
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });
</script>

```

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    const getTodos = async ()=>{
        try{
            // response로 받아서 data 꺼내기
            const response = await axios.get('http://localhost:9999/todos');
            console.log(response.data);
            
            // data 프로퍼티만 바로 꺼내기
            const {data} = await axios.get('http://localhost:9999/todos');
            console.log(data);
        } catch(error){
            console.error(error);
        }
    };
    getTodos();
</script>

```

### Axios 라이브러리를 불러오는 코드

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>

```

이 한 줄은 **Axios 라이브러리**를 불러오는 코드입니다.

---

1. `unpkg.com` 이란?

- **npm 패키지용 CDN(Content Delivery Network)** 서비스입니다.
- npm에 올라와 있는 라이브러리를 브라우저에서 `<script>` 태그로 바로 불러와 쓸 수 있게 해줘요.

즉, npm으로 설치하지 않고도 웹페이지에서 바로 라이브러리를 쓸 수 있습니다.

---

2. `axios/dist/axios.min.js`

- **axios** 라이브러리의 “브라우저용 번들 파일” 경로입니다.
- `min.js`는 **minified(압축된)** 버전이라, 공백·주석을 다 지우고 코드 크기를 줄여둔 파일이에요.
- 이 파일이 로드되면 전역 스코프에 `axios` 객체가 등록됩니다.

---

✅ 정리

- 저 한 줄은 **CDN을 통해 axios 라이브러리를 가져오는 코드**
- 그래서 npm 설치 없이도 바로 `<script>` 안에서 `axios`를 쓸 수 있게 됩니다.

---

### 특정 id의 todo만 보기

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    axios
    .get('http://localhost:9999/todos?id=1')
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });

    axios
    .get('http://localhost:9999/todos', {params:{id:2}})
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });

    axios
    .get('http://localhost:9999/todos/3')
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });
</script>

```

## 2. POST 요청

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    axios
    .post('http://localhost:9999/todos',{
        title: 'Learn NodeJS',
        completed: false
    })
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });
</script>

```

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    const postTodos = async ()=>{
        try{
            const response = await axios.post('http://localhost:9999/todos',{
                title: 'express 과제하기',
                completed: false
            });
            console.log(response.data);
        } catch(error){
            console.error(error);
        }
    };
    postTodos();
</script>

```

## 3. PUT 요청

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    axios
    .put('http://localhost:9999/todos/1',{
        title: '공책 사기',
        completed: false
    })
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });
</script>

```

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    const putTodo = async ()=>{
        try{
            const response = await axios.put('http://localhost:9999/todos/1',{
                title: '회귀분석 과제하기',
                completed: false
            });
            console.log(response.data);
        } catch(error){
            console.error(error);
        }
    };
    putTodo();
</script>

```

## 4. DELETE 요청

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    axios
    .delete('http://localhost:9999/todos/1')
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });
</script>

```

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    const deleteTodo = async ()=>{
        try{
            const response = await axios.delete('http://localhost:9999/todos/2');
            console.log(response.data);
        } catch(error){
            console.error(error);
        }
    };
    deleteTodo();
</script>

```

---


# 7. FormData

<img width="1410" height="854" alt="image" src="https://github.com/user-attachments/assets/8cc98468-b712-452e-aeba-7f707847cf6a" />

## 실습1

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>FormData 예제(프로필 등록)</title>
</head>
<body>
    <h1>프로필 등록</h1>
    <form id="profile-form">
        <label for="username">이름:</label>
        <input type="text" id="username" name="username" required>
        <br><br>

        <label for="email">이메일:</label>
        <input type="email" id="email" name="email" required>
        <br><br>

        <button type="submit">서버로 제출</button>
    </form>

    <div id="result"></div>

    <script src="profile-app.js"></script>
</body>
</html>

```

```jsx
const myForm = document.getElementById('profile-form');
const resultDiv = document.getElementById('result');

myForm.addEventListener('submit', function(event){
    event.preventDefault();  // AJAX를 위해 폼 제출 시 새로고침 동작을 막음

    const formData = new FormData(myForm);

    const dataObj = Object.fromEntries(formData.entries());

    fetch('http://localhost:3000/profiles',{
        method:'POST',
        headers:{
            'Content-Type':'application/json',
        },
        body: JSON.stringify(dataObj),
    })
    .then(response => response.json())
    .then(data=>{
        console.log('성공: ', data);
        resultDiv.innerHTML=`
        <strong>서버에 등록 성공</strong>
        <p>
            ID: ${data.id} <br>
            Name: ${data.username} <br>
            Email: ${data.email} <br>
        </p>
        `;
        myForm.reset(); // 성공 후 폼 내용 초기화
    })
    .catch((error)=>{
        console.error('실패: ', error);
        resultDiv.innerHTML = `<p>오류 발생</p>`;
    })
})

```

### 1. `event.preventDefault();` 의 역할

- 기본적으로 `<form>`은 **submit(제출)** 하면 브라우저가 페이지를 새로고침하면서 서버로 데이터를 전송합니다.
- 하지만 우리는 **fetch API**로 직접 Ajax 요청을 보내고 싶기 때문에 **폼의 기본 동작(새로고침)**을 막아야 해요.
- 그래서 `event.preventDefault()`를 호출하면 👉 **폼이 새로고침되지 않고, 우리가 작성한 JavaScript 코드로 제어**할 수 있습니다.

---

### 2. `formData.entries()` 예시

코드에서

```jsx
const formData = new FormData(myForm);

```

하면, `<form>` 안의 입력 요소들이 자동으로 수집됩니다.

예를 들어, 사용자가 입력을 이렇게 했다면:

- `username` 입력칸: `"세민"`
- `email` 입력칸: `"semin@example.com"`

`formData.entries()`는 키-값 쌍을 이터러블(iterable)로 반환해요.

➡️ 실제로는 이런 데이터가 들어있습니다:

```jsx
for (let pair of formData.entries()) {
  console.log(pair);
}

```

출력:

```
["username", "세민"]
["email", "semin@example.com"]

```

즉, 배열 형태로 각각의 `<input name="...">`와 입력된 값이 묶여서 들어갑니다.

---

### 3. `Object.fromEntries(formData.entries())` 의 결과

`Object.fromEntries()`는 저런 배열 쌍들을 **객체**로 변환해줍니다.

따라서 `dataObj`는 이렇게 됩니다:

```jsx
{
  username: "세민",
  email: "semin@example.com"
}

```

---

### 4. 최종 요청으로 넘어가는 `body`

그 후에:

```jsx
body: JSON.stringify(dataObj)

```

이 부분에서 JSON 문자열로 변환되기 때문에, 서버로 전송되는 실제 데이터는 이렇게 됩니다:

```json
{
  "username": "세민",
  "email": "semin@example.com"
}

```

---

✅ 정리

1. `event.preventDefault();` → 폼의 기본 새로고침 동작 막음.
2. `formData.entries()` → `[["username", "세민"], ["email", "semin@example.com"]]` 이런 배열 쌍.
3. `Object.fromEntries(...)` → `{ username: "세민", email: "semin@example.com" }` 객체.
4. 서버에는 JSON 문자열로 변환되어 POST 요청됨.

---

## 실습2: form data 다루기, 다중 값을 지원하는 객체로 만들기

```json
{
  "profiles": [],
  "posts": []
}
```

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>FormData 직접 조작/다중 값 처리 예제</title>
</head>
<body>
    <h1>FormData 직접 조작 후 전송</h1>
    <h3>: 하나의 Key-여러 Value 처리</h3>
    <button id="send-data-btn">서버로 데이터 전송</button>
    
    <div id="posts-result"></div>
    
    <script src="posts-app.js"></script>
</body>
</html>

```

```jsx
const sendButton = document.getElementById('send-data-btn');
const resultDiv = document.getElementById('posts-result');

sendButton.addEventListener('click', ()=>{
    const postData = new FormData();
    postData.append('userId', '12345');
    postData.append('posts', 'FormData is good');
    postData.append('comment', 'Great post');
    postData.append('tags', 'JS');
    postData.append('tags', 'Frontend');
    postData.append('tags', 'WebDev');

    // 1. form data 내용 확인: for문
    console.log('1. postData 내용 확인: for문');
    for(const [key, value] of postData.entries()){
        console.log(`${key}:`, value);
    }

    // 2. form data 내용 확인: get(All), has
    console.log('2. postData 내용 확인: get(All), has');
    console.log('userId: ', postData.get('userID'));
    console.log('tags: ', postData.getAll('tags'));
    console.log('comment? ', postData.has('comment'));
    console.log('posts: ', postData.get('posts'));

    // 3. form data 삭제, 수정: delete, set
    console.log('3. postData 삭제, 수정: delete, set');
    postData.delete('comment');
    console.log('comment? ', postData.has('comment'));
    postData.set('posts', 'edited posts!')
    console.log('posts: ', postData.get('posts'));

    // 4. form data를 다중 값을 지원하는 객체로 변환
    console.log('form data를 다중 값을 지원하는 객체로 변환:')
    const dataObj = {};
    for(const key of new Set(postData.keys())){
        const values = postData.getAll(key);

        dataObj[key] = values.length > 1 ? values : values[0];
    }
    console.log('변환된 객체: ', dataObj);

    fetch('http://localhost:3000/posts',{
        method:'POST',
        headers:{
            'Content-Type':'application/json'
        },
        body: JSON.stringify(postData)
    })
    .then(response=>response.json())
    .then(data=>{
        resultDiv.innerHTML = `
            <p>
            서버에 아래 데이터가 저장됐습니다.
            </p>
            <pre>${JSON.stringify(data, null, 2)}</pre>
        `
    })
    .catch(error=>{
        resultDiv.innerHTML = `
            <p>
            오류가 발생했습니다.
            </p>
        `
    })
})

```

---

# 8. encode/decodeURIComponent

<img width="1394" height="803" alt="image" src="https://github.com/user-attachments/assets/051c2032-a7fe-4605-94da-85efd6e3054b" />

<img width="1443" height="402" alt="image" src="https://github.com/user-attachments/assets/536a78ee-28a5-46c3-a1cd-81d4fa280a02" />

---

# 9. data attribute와 dataset

```html
    <ul>
        <li data-id="1" data-user-job="programmer">Zero</li>
        <li data-id="2" data-user-job="designer">Nero</li>
        <li data-id="3" data-user-job="programmer">Hero</li>
        <li data-id="4" data-user-job="ceo">Kero</li>
    </ul>
    <script>
        console.log(document.querySelector('li').dataset);
    </script>
```

### 1️⃣ `data-*` 속성

- HTML5에서 새롭게 도입된 **커스텀 데이터 속성(Custom Data Attribute)** 입니다.
- 속성 이름은 `data-`로 시작해야 하고, 이후 이름은 자유롭게 지정 가능.
- 예시:

```html
<li data-id="1" data-user-job="programmer">Zero</li>

```

- 여기서:
    - `data-id="1"` → id 값
    - `data-user-job="programmer"` → 사용자 직업 정보

💡 장점:

- JS에서 쉽게 접근 가능
- HTML 구조를 바꾸지 않고 추가 정보 저장 가능

---

### 2️⃣ `dataset` 속성

- `dataset`은 **HTML 요소의 data-* 속성을 객체 형태로 접근**하게 해주는 DOM 프로퍼티입니다.
- 예시:

```jsx
const li = document.querySelector('li');
console.log(li.dataset);

```

출력 결과:

```jsx
DOMStringMap { id: "1", userJob: "programmer" }

```

- **자동으로 camelCase 변환**:
    - HTML: `data-user-job` → JS: `dataset.userJob`

---

### 3️⃣ `document.querySelector('li')`

- DOM에서 **첫 번째 `<li>` 요소**를 선택합니다.
- `querySelector`는 CSS 선택자 문법을 그대로 사용할 수 있어요.

---

### 4️⃣ 코드 동작 요약

```jsx
console.log(document.querySelector('li').dataset);

```

1. `document.querySelector('li')` → 첫 번째 `<li>` 선택 (`<li data-id="1" data-user-job="programmer">Zero</li>`)
2. `.dataset` → 선택한 `<li>`의 모든 data-* 속성을 **객체 형태**로 가져옴
3. `console.log` → 브라우저 콘솔에 `{ id: "1", userJob: "programmer" }` 출력

즉, **HTML 요소의 data-* 속성을 JS 객체처럼 쉽게 다룰 수 있는 방법**을 보여주는 예제입니다.

---

- HTML 태그에 데이터를 저장하는 방법
    - 서버의 데이터를 fe로 보낼 때 그 값을 저장
    - 태그 속성으로 `data-속성명` 을 사용
    - JS에서 `태그.dataset.속성명` 으로 접근 가능
    - 반대로 JS dataset에 값을 넣으면 `data-속성`이 생김

---

### 1️⃣ data attribute / dataset을 **사용하는 예시 vs 사용하지 않는 예시**

### ✅ data attribute 사용하는 경우

```html
<ul>
  <li data-id="1" data-job="programmer">Zero</li>
  <li data-id="2" data-job="designer">Nero</li>
</ul>

<script>
  document.querySelectorAll("li").forEach(li => {
    li.addEventListener("click", () => {
      // dataset에서 직접 정보 가져옴
      console.log(li.textContent, li.dataset.job);
    });
  });
</script>

```

👉 클릭 시 `"Zero programmer"`, `"Nero designer"` 출력됨

👉 **장점**: 클릭된 태그와 데이터가 같이 있으므로, 별도의 "데이터 찾기" 과정이 필요 없음

---

### ❌ data attribute 사용하지 않는 경우

```html
<ul>
  <li>Zero</li>
  <li>Nero</li>
</ul>

<script>
  // 데이터는 JS 객체에 따로 저장
  const users = [
    { id: 1, name: "Zero", job: "programmer" },
    { id: 2, name: "Nero", job: "designer" }
  ];

  document.querySelectorAll("li").forEach((li, index) => {
    li.addEventListener("click", () => {
      // li와 매칭되는 데이터를 배열에서 찾아야 함
      console.log(users[index].name, users[index].job);
    });
  });
</script>

```

👉 클릭 시 `"Zero programmer"`, `"Nero designer"` 출력됨

👉 **단점**: DOM 태그와 데이터를 별도로 관리해야 해서 매칭(인덱스, id 비교)이 필요함

---

### 2️⃣ "렌더링(rendering)"의 뜻

- *컴퓨터 그래픽스/웹 개발에서 "그리는 과정"**을 의미해요.
- 서버에서 받아온 데이터(JSON 등)를 **화면에 보이는 HTML로 변환하는 과정**을 "렌더링한다"라고 부릅니다.

👉 예를 들어:

- 서버에서 `"name: Zero, job: programmer"` 라는 데이터 받음
- 이걸 브라우저가 보여줄 수 있는 `<li data-job="programmer">Zero</li>`로 변환해서 화면에 붙임
- 이 과정을 **렌더링**이라고 해요.

---

### 3️⃣ 순수 JS + DOM 기반 개발에서 직관적인 예시

프레임워크가 없던 시절(React, Vue 이전), 순수 JS만 썼을 때 자주 쓰던 방식이에요.

### ✅ data attribute 활용

```html
<button data-product-id="101">장바구니 추가</button>
<button data-product-id="102">장바구니 추가</button>

<script>
  document.querySelectorAll("button").forEach(btn => {
    btn.addEventListener("click", e => {
      const productId = e.target.dataset.productId; // 버튼에서 직접 ID 읽기
      console.log(productId + "번 상품 장바구니에 추가!");
    });
  });
</script>

```

👉 **버튼 하나하나가 자기 상품 정보를 직접 가지고 있으니 직관적**

👉 "어떤 버튼이 눌렸는지"만 알면, 바로 데이터에 접근 가능

---

### ❌ data attribute 없이 구현 (불편한 경우)

```html
<button>장바구니 추가</button>
<button>장바구니 추가</button>

<script>
  const products = [101, 102]; // 따로 관리해야 함

  document.querySelectorAll("button").forEach((btn, idx) => {
    btn.addEventListener("click", () => {
      console.log(products[idx] + "번 상품 장바구니에 추가!");
    });
  });
</script>

```

👉 이 경우 버튼만 보고는 어떤 상품인지 알 수 없고, **배열(products)** 과 인덱스를 맞춰야 함

---

### ✅ 정리

1. `data-*`는 **태그와 데이터를 강하게 연결**할 때 직관적임.
2. "렌더링"은 데이터를 화면에 보여주는 HTML로 그리는 과정.
3. 순수 JS + DOM 시절에는 `data-*`가 특히 편했음 (프레임워크 이전에는 사실상 필수처럼 쓰였음).

---


