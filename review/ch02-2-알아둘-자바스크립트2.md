

# 1. 정적/동적 웹 사이트

---

# 2. AJAX

: Asynchronous JS and XML

- 웹페이지 전체를 새로고침하지 않고, 필요한 데이터만 요청 후 일부만 업데이트(새로고침)
- Asynchronous 통신 방식: 사용자는 응답을 기다리지 않고(백그라운드에서 데이터를 찾아서 줌) 웹 페이지 사용 가능
- 데이터 전송 방식(XML): But, Json으로 전송해도 AJAX라고 함!

---

# 3. JSON(JS Object Notaion)

: JS 객체 문법으로 나타낸 문자열 형태의 포맷이다. 서버와 클라이언트의 데이터 통신 시 자주 사용하는 포맷.

- Parsing: JSON → JS 객체
- Stringification(문자열화): JS객체 → JSON

Q. 강의자료 12페이지에 `response.json()`가 응답 데이터를 JSON 객체로 파싱한다고 적혀있었다.
JSON의 parsing, stringification의 정의에 따르면 JS객체와 JSON문자열의 관계인데, 왜 'JSON객체'라는 워딩이 나온 걸까?

<img width="1417" height="945" alt="image" src="https://github.com/user-attachments/assets/1fd68d20-0365-4e15-a404-d6ff3934ea44" />

-> GPT
정확히는
JSON은 객체(Object)가 아니라 문자열 데이터 포맷
자바스크립트 객체(Object)와 문자열로 표현된 JSON을 왔다갔다 할 수 있음

교수님 주석은 학생 이해를 쉽게 하려고 편의상 ‘JSON 객체’라고 쓴 것일 가능성이 큼.
하지만 정확하게 말하면 response.json()은 JSON → JS 객체 변환 과정

“JSON 객체” = ❌ (틀린 표현, 실제론 없음)
“JSON 문자열” ✅
“JavaScript 객체” ✅

---

# 4. Json-Server

- 백엔드 서버를 구축하지 않고 JSON 파일만 있으면 RESTful API 생성 가능 → 테스트, 프로토타입 작업 용이
- 실행 코드
    
    ```bash
    json-server --port 9999 todos.json
    ```
    
    → http://localhost:9999/todos/2 → id가 2인 객체를 get 요청하는 url
    

---

# 5. Fetch API

### fetch에 보내는 url 인자

```jsx
fetch(url)

```

- `url`을 인자로 주면 **기본값으로 GET 요청**을 보냅니다.
- `fetch("http://localhost:9999/todos/2")`나
    
    `fetch("http://localhost:9999/todos?id=2")` 둘 다 똑같이 **GET 요청**을 날려요.
    

즉, 별도 설정 안 하면 `fetch`는 무조건 GET입니다.

---

### 두 URL의 차이

- `http://localhost:9999/todos/2`
    
    → **RESTful 방식**: 특정 리소스(`id=2`인 todo)를 의미
    
    → 보통 서버 라우터에서 `/todos/:id` 형태로 처리
    
- `http://localhost:9999/todos?id=2`
    
    → **쿼리스트링 방식**: todos를 조회하는데, 조건으로 `id=2`를 줌
    
    → 서버 라우터에서 `/todos` 요청을 받되, query parameter `id`를 읽어서 처리
    

---

```jsx
const url = new URL('http://localhost:9999/todos');
const params = new URLSearchParams({ id : 2 });
url.search = params;

fetch(url)
	.then ~ 뒤는 생략 ~
```

위 코드에서 `fetch(url)`에 전달되는 **최종 URL은 `"http://localhost:9999/todos?id=2"`** 

### `URL` 객체

- `new URL('http://example.com/path?x=1')` 처럼 브라우저(또는 Node의 WHATWG URL)에 내장된 객체예요.
- URL을 구성 요소(프로토콜, 호스트, pathname, search, hash 등)로 쉽게 다룰 수 있게 해줍니다.
- 주요 프로퍼티:
    - `url.href` or `url.toString()` : 전체 문자열 URL
    - `url.protocol`, `url.hostname`, `url.port`, `url.pathname` 등
    - `url.search` : 쿼리 문자열(앞에 `?` 포함된 문자열)
    - `url.searchParams` : `URLSearchParams` 객체

### `URLSearchParams`

- 쿼리 문자열을 만들고 다루기 위한 편리한 인터페이스입니다.
- 생성 가능:
    - `new URLSearchParams('a=1&b=2')`
    - `new URLSearchParams({ a: 1, b: 2 })` (값들은 문자열로 변환됨)
- 유용한 메서드: `append`, `set`, `get`, `getAll`, `has`, `delete`, `toString`, `sort` 등.
    - `params.toString()` → `'a=1&b=2'` (자동으로 URL-인코딩 처리)

### `url.search` vs `url.searchParams`

- `url.search`는 **문자열**(예: `'?id=2&x=3'`)입니다.
- `url.searchParams`는 **`URLSearchParams` 객체**로 쿼리 파라미터를 조작할 수 있게 해줍니다.
- 둘은 연결되어 있어 `url.searchParams.set('id','2')`를 하면 `url.search`도 자동으로 바뀝니다.

### 코드 한 줄씩 동작 설명

```jsx
const url = new URL('http://localhost:9999/todos');
const params = new URLSearchParams({ id : 2 });
url.search = params;

fetch(url)
  .then( /* ... */ )

```

1. `new URL('http://localhost:9999/todos')`
    - `url`은 pathname `/todos`를 가진 URL 객체가 됩니다.
2. `new URLSearchParams({ id: 2 })`
    - `params`는 쿼리 파라미터 객체이고, `params.toString()`은 `'id=2'` 입니다.
3. `url.search = params;`
    - 여기서 `params`(객체)는 내부적으로 문자열로 변환되어 (`params.toString()`) `url.search`에 들어갑니다.
    - 결과적으로 `url.search === '?id=2'` 이 됩니다. (브라우저가 `?`를 붙여줍니다.)
    - **주의**: 보통은 `url.search = params.toString()` 또는 `url.searchParams = params` 혹은 `url.searchParams.set('id','2')`처럼 명시적으로 쓰기도 합니다. 하지만 `url.search = params`처럼 `URLSearchParams` 객체를 할당해도 문자열로 변환되어 동작합니다.
4. `fetch(url)`
    - `fetch`에 `URL` 객체를 넘기면 내부적으로 `url.toString()` (또는 `String(url)`)이 호출되어 **문자열 형태의 전체 URL**로 요청을 보냅니다.
    - 따라서 보내는 요청은 `GET http://localhost:9999/todos?id=2` 입니다.

---

## 1. GET 요청

```html
<script>
		// 1. promise then/catch 사용
    fetch('http://localhost:9999/todos')
        .then((response)=>{ // "서버가 클라이언트에게 보내준" HTTP "응답 전체"를 나타내는 Response 객체
            if(!response.ok){
                throw new Error('Network response was not ok');
            }
            return response.json()
        })
        .then((data)=>{
            console.log(data);
        })
        .catch((error)=>{
            console.error('Fetch error:', error);
        });
				
				// 2. async/await 사용
        const getTodos = async ()=>{
            try{
                const response = await fetch('http://localhost:9999/todos'); // 서버로 GET 요청 보냄
                if(!response.ok){
                    throw new Error('Network response was not ok');
                }

                const data = await response.json(); // response.json()은 비동기 메서드
                console.log(data);
            } catch(error){
                console.error('Fetch error:',error);
            }
        };
        getTodos();
</script>

```

<img width="1501" height="931" alt="image" src="https://github.com/user-attachments/assets/d9278cf0-66d9-4326-bc76-1f91a8fb5419" />





![image.png](attachment:4f2bff60-b64c-479c-a798-134a8ee8b5b5:image.png)
