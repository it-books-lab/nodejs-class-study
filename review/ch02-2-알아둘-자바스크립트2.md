

# 1. 정적/동적 웹 사이트

---

# 2. AJAX

: Asynchronous JS and XML

- 웹페이지 전체를 새로고침하지 않고, 필요한 데이터만 요청 후 일부만 업데이트(새로고침)
- Asynchronous 통신 방식: 사용자는 응답을 기다리지 않고(백그라운드에서 데이터를 찾아서 줌) 웹 페이지 사용 가능
- 데이터 전송 방식(XML): But, Json으로 전송해도 AJAX라고 함!

---

# 3. JSON(JS Object Notaion)

: JS 객체 문법으로 나타낸 문자열 형태의 포맷이다. 서버와 클라이언트의 데이터 통신 시 자주 사용하는 포맷.

- Parsing: JSON → JS 객체
- Stringification(문자열화): JS객체 → JSON

Q. 강의자료 12페이지에 `response.json()`가 응답 데이터를 JSON 객체로 파싱한다고 적혀있었다.
JSON의 parsing, stringification의 정의에 따르면 JS객체와 JSON문자열의 관계인데, 왜 'JSON객체'라는 워딩이 나온 걸까?

<img width="1417" height="945" alt="image" src="https://github.com/user-attachments/assets/1fd68d20-0365-4e15-a404-d6ff3934ea44" />

-> GPT
정확히는
JSON은 객체(Object)가 아니라 문자열 데이터 포맷
자바스크립트 객체(Object)와 문자열로 표현된 JSON을 왔다갔다 할 수 있음

교수님 주석은 학생 이해를 쉽게 하려고 편의상 ‘JSON 객체’라고 쓴 것일 가능성이 큼.
하지만 정확하게 말하면 response.json()은 JSON → JS 객체 변환 과정

“JSON 객체” = ❌ (틀린 표현, 실제론 없음)
“JSON 문자열” ✅
“JavaScript 객체” ✅

---

# 4. Json-Server

- 백엔드 서버를 구축하지 않고 JSON 파일만 있으면 RESTful API 생성 가능 → 테스트, 프로토타입 작업 용이
- 실행 코드
    
    ```bash
    json-server --port 9999 todos.json
    ```
    
    → http://localhost:9999/todos/2 → id가 2인 객체를 get 요청하는 url
    

---

# 5. Fetch API

### fetch에 보내는 url 인자

```jsx
fetch(url)

```

- `url`을 인자로 주면 **기본값으로 GET 요청**을 보냅니다.
- `fetch("http://localhost:9999/todos/2")`나
    
    `fetch("http://localhost:9999/todos?id=2")` 둘 다 똑같이 **GET 요청**을 날려요.
    

즉, 별도 설정 안 하면 `fetch`는 무조건 GET입니다.

---

### 두 URL의 차이

- `http://localhost:9999/todos/2`
    
    → **RESTful 방식**: 특정 리소스(`id=2`인 todo)를 의미
    
    → 보통 서버 라우터에서 `/todos/:id` 형태로 처리
    
- `http://localhost:9999/todos?id=2`
    
    → **쿼리스트링 방식**: todos를 조회하는데, 조건으로 `id=2`를 줌
    
    → 서버 라우터에서 `/todos` 요청을 받되, query parameter `id`를 읽어서 처리
    

---

```jsx
const url = new URL('http://localhost:9999/todos');
const params = new URLSearchParams({ id : 2 });
url.search = params;

fetch(url)
	.then ~ 뒤는 생략 ~
```

위 코드에서 `fetch(url)`에 전달되는 **최종 URL은 `"http://localhost:9999/todos?id=2"`** 

### `URL` 객체

- `new URL('http://example.com/path?x=1')` 처럼 브라우저(또는 Node의 WHATWG URL)에 내장된 객체예요.
- URL을 구성 요소(프로토콜, 호스트, pathname, search, hash 등)로 쉽게 다룰 수 있게 해줍니다.
- 주요 프로퍼티:
    - `url.href` or `url.toString()` : 전체 문자열 URL
    - `url.protocol`, `url.hostname`, `url.port`, `url.pathname` 등
    - `url.search` : 쿼리 문자열(앞에 `?` 포함된 문자열)
    - `url.searchParams` : `URLSearchParams` 객체

### `URLSearchParams`

- 쿼리 문자열을 만들고 다루기 위한 편리한 인터페이스입니다.
- 생성 가능:
    - `new URLSearchParams('a=1&b=2')`
    - `new URLSearchParams({ a: 1, b: 2 })` (값들은 문자열로 변환됨)
- 유용한 메서드: `append`, `set`, `get`, `getAll`, `has`, `delete`, `toString`, `sort` 등.
    - `params.toString()` → `'a=1&b=2'` (자동으로 URL-인코딩 처리)

### `url.search` vs `url.searchParams`

- `url.search`는 **문자열**(예: `'?id=2&x=3'`)입니다.
- `url.searchParams`는 **`URLSearchParams` 객체**로 쿼리 파라미터를 조작할 수 있게 해줍니다.
- 둘은 연결되어 있어 `url.searchParams.set('id','2')`를 하면 `url.search`도 자동으로 바뀝니다.

### 코드 한 줄씩 동작 설명

```jsx
const url = new URL('http://localhost:9999/todos');
const params = new URLSearchParams({ id : 2 });
url.search = params;

fetch(url)
  .then( /* ... */ )

```

1. `new URL('http://localhost:9999/todos')`
    - `url`은 pathname `/todos`를 가진 URL 객체가 됩니다.
2. `new URLSearchParams({ id: 2 })`
    - `params`는 쿼리 파라미터 객체이고, `params.toString()`은 `'id=2'` 입니다.
3. `url.search = params;`
    - 여기서 `params`(객체)는 내부적으로 문자열로 변환되어 (`params.toString()`) `url.search`에 들어갑니다.
    - 결과적으로 `url.search === '?id=2'` 이 됩니다. (브라우저가 `?`를 붙여줍니다.)
    - **주의**: 보통은 `url.search = params.toString()` 또는 `url.searchParams = params` 혹은 `url.searchParams.set('id','2')`처럼 명시적으로 쓰기도 합니다. 하지만 `url.search = params`처럼 `URLSearchParams` 객체를 할당해도 문자열로 변환되어 동작합니다.
4. `fetch(url)`
    - `fetch`에 `URL` 객체를 넘기면 내부적으로 `url.toString()` (또는 `String(url)`)이 호출되어 **문자열 형태의 전체 URL**로 요청을 보냅니다.
    - 따라서 보내는 요청은 `GET http://localhost:9999/todos?id=2` 입니다.

---

## 1. GET 요청

```html
<script>
		// 1. promise then/catch 사용
    fetch('http://localhost:9999/todos')
        .then((response)=>{ // "서버가 클라이언트에게 보내준" HTTP "응답 전체"를 나타내는 Response 객체
            if(!response.ok){
                throw new Error('Network response was not ok');
            }
            return response.json()
        })
        .then((data)=>{
            console.log(data);
        })
        .catch((error)=>{
            console.error('Fetch error:', error);
        });
				
				// 2. async/await 사용
        const getTodos = async ()=>{
            try{
                const response = await fetch('http://localhost:9999/todos'); // 서버로 GET 요청 보냄
                if(!response.ok){
                    throw new Error('Network response was not ok');
                }

                const data = await response.json(); // response.json()은 비동기 메서드
                console.log(data);
            } catch(error){
                console.error('Fetch error:',error);
            }
        };
        getTodos();
</script>

```

<img width="1501" height="931" alt="image" src="https://github.com/user-attachments/assets/d9278cf0-66d9-4326-bc76-1f91a8fb5419" />


---

### id가 1인 경우만 GET

```html
<script>
    fetch('http://localhost:9999/todos?id=1')
        .then((response)=>{
            if(!response.ok){
                throw new Error('Network response was not ok');
            }
            return response.json()
        })
        .then((data)=>{
            console.log(data);
        })
        .catch((error)=>{
            console.error('Fetch error:', error);
        });
</script>

```

## 2. POST 요청

- Promise 체인 방식

```html
<script>
    const postData = {
        title: 'Learn NodeJS',
        completed: false
    };

    fetch('http://localhost:9999/todos',{
        method: 'POST',
        headers:{
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(postData) // 문자열로 변환하여 전송
    })
        .then((response)=>{
            if(!response.ok){
                throw new Error('Network response was not ok');
            }
            return response.json()
        })
        .then((data)=>{
            console.log(data);
        })
        .catch((error)=>{
            console.error('Fetch error:', error);
        });
</script>

```

- async, await 방식

```html
<script>
        const postTodos = async ()=>{
            try{
                const response = await fetch('http://localhost:9999/todos',{
                    method : 'POST',
                    headers : {
                        'Content-Type':'application/json'
                   },
                    body : JSON.stringify({
                        title: 'Express 공부하기',
                        completed: false
                    })
                });
                if(!response.ok){
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                console.log(data);
            } catch(error){
                console.error('Fetch error:',error);
            }
        };
        postTodos();
</script>

```

---

## 3. PUT 요청

```html
<script>
    const putData = {
        title: 'Learn React',
        completed: false
    };

    fetch('http://localhost:9999/todos/1',{
        method: 'PUT',
        headers:{
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(putData)
    })
        .then((response)=>{
            if(!response.ok){
                throw new Error('Network response was not ok');
            }
            return response.json()
        })
        .then((data)=>{
            console.log(data);
        })
        .catch((error)=>{
            console.error('Fetch error:', error);
        });
</script>

```

```html
<script>
        const putTodos = async ()=>{
            try{
                const response = await fetch('http://localhost:9999/todos/1',{
                    method : 'PUT',
                    headers : {
                        'Content-Type':'application/json'
                    },
                    body : JSON.stringify({
                        title: 'Learn JS',
                        completed: true
                    })
                });
                if(!response.ok){
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                console.log(data);
            } catch(error){
                console.error('Fetch error:',error);
            }
        };
        putTodos();
</script>

```

## 4. DELETE 요청

```html
<script>
    fetch('http://localhost:9999/todos/1',{
        method: 'DELETE',
    })
        .then((response)=>{
            if(!response.ok){
                throw new Error('Network response was not ok');
            }
            return response.text().then(text=>text?JSON.parse(text):{});
        })
        .then((data)=>{
            console.log('Successfully deleted: ', data);
        })
        .catch((error)=>{
            console.error('Fetch error:', error);
        });
</script>

```

```html
<script>
        const deleteTodos = async ()=>{
            try{
                const response = await fetch('http://localhost:9999/todos/2',{
                    method : 'DELETE',
                });
                if(!response.ok){
                    throw new Error('Network response was not ok');
                }
                const data = await response.text().then(text=>text?JSON.parse(text):{});
                console.log('Successfully deleted: ', data);
            } catch(error){
                console.error('Fetch error:',error);
            }
        };
        deleteTodos();
</script>

```

```jsx
return response.text()
    .then(text => text ? JSON.parse(text) : {});

```

---

### 1. `response.text()`

- 서버의 응답(body)을 **문자열(String)** 로 꺼내옵니다.
- `response.json()`과 달리, 자동으로 파싱하지 않고 그냥 텍스트 그대로 줍니다.

예를 들어 서버가 빈 응답을 주면 `""` (빈 문자열)을 반환합니다.

---

### 2. `.then(text => text ? JSON.parse(text) : {})`

- `text`가 비어 있지 않으면(`truthy`) → `JSON.parse(text)` 실행해서 JS 객체로 변환
- `text`가 비어 있으면(`""` → falsy) → 그냥 빈 객체 `{}` 반환

즉,

- 응답 본문이 JSON 문자열일 경우에는 정상적으로 파싱
- 응답 본문이 **빈 문자열**일 경우에는 에러 나지 않도록 안전하게 `{}`를 대신 반환

---

### 3. 왜 이렇게 쓸까?

`DELETE` 요청의 응답은 보통 **본문이 없는 경우**가 많습니다.

(HTTP 204 No Content 같은 경우)

- 만약 그냥 `response.json()`을 쓰면:
    
    → 빈 문자열을 JSON으로 파싱하려다가 에러가 납니다.
    
- 그래서 `response.text()`로 문자열을 꺼내고,
    
    → 있으면 `JSON.parse` 하고,
    
    → 없으면 `{}` 반환해서 안전하게 처리하는 거예요.
    

---

✅ 정리하면:

```jsx
return response.text().then(text => text ? JSON.parse(text) : {});

```

👉 **“응답 본문이 있으면 JSON으로 파싱, 없으면 빈 객체로 반환”** 이라는 안전장치입니다.

---

# Axios API

## 1. GET 요청

### 모든 todos 보기

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    axios
    .get('http://localhost:9999/todos')
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });
</script>

```

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    const getTodos = async ()=>{
        try{
            // response로 받아서 data 꺼내기
            const response = await axios.get('http://localhost:9999/todos');
            console.log(response.data);
            
            // data 프로퍼티만 바로 꺼내기
            const {data} = await axios.get('http://localhost:9999/todos');
            console.log(data);
        } catch(error){
            console.error(error);
        }
    };
    getTodos();
</script>

```

### Axios 라이브러리를 불러오는 코드

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>

```

이 한 줄은 **Axios 라이브러리**를 불러오는 코드입니다.

---

1. `unpkg.com` 이란?

- **npm 패키지용 CDN(Content Delivery Network)** 서비스입니다.
- npm에 올라와 있는 라이브러리를 브라우저에서 `<script>` 태그로 바로 불러와 쓸 수 있게 해줘요.

즉, npm으로 설치하지 않고도 웹페이지에서 바로 라이브러리를 쓸 수 있습니다.

---

2. `axios/dist/axios.min.js`

- **axios** 라이브러리의 “브라우저용 번들 파일” 경로입니다.
- `min.js`는 **minified(압축된)** 버전이라, 공백·주석을 다 지우고 코드 크기를 줄여둔 파일이에요.
- 이 파일이 로드되면 전역 스코프에 `axios` 객체가 등록됩니다.

---

✅ 정리

- 저 한 줄은 **CDN을 통해 axios 라이브러리를 가져오는 코드**
- 그래서 npm 설치 없이도 바로 `<script>` 안에서 `axios`를 쓸 수 있게 됩니다.

---

### 특정 id의 todo만 보기

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    axios
    .get('http://localhost:9999/todos?id=1')
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });

    axios
    .get('http://localhost:9999/todos', {params:{id:2}})
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });

    axios
    .get('http://localhost:9999/todos/3')
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });
</script>

```

## 2. POST 요청

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    axios
    .post('http://localhost:9999/todos',{
        title: 'Learn NodeJS',
        completed: false
    })
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });
</script>

```

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    const postTodos = async ()=>{
        try{
            const response = await axios.post('http://localhost:9999/todos',{
                title: 'express 과제하기',
                completed: false
            });
            console.log(response.data);
        } catch(error){
            console.error(error);
        }
    };
    postTodos();
</script>

```

## 3. PUT 요청

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    axios
    .put('http://localhost:9999/todos/1',{
        title: '공책 사기',
        completed: false
    })
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });
</script>

```

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    const putTodo = async ()=>{
        try{
            const response = await axios.put('http://localhost:9999/todos/1',{
                title: '회귀분석 과제하기',
                completed: false
            });
            console.log(response.data);
        } catch(error){
            console.error(error);
        }
    };
    putTodo();
</script>

```

## 4. DELETE 요청

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    axios
    .delete('http://localhost:9999/todos/1')
    .then((result)=>{
        console.log(result.data);
    })
    .catch((error)=>{
        console.error(error);
    });
</script>

```

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    const deleteTodo = async ()=>{
        try{
            const response = await axios.delete('http://localhost:9999/todos/2');
            console.log(response.data);
        } catch(error){
            console.error(error);
        }
    };
    deleteTodo();
</script>

```

---




